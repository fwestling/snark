// This file is part of snark, a generic and flexible library for robotics research
// Copyright (c) 2011 The University of Sydney
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University of Sydney nor the
//    names of its contributors may be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE
// GRANTED BY THIS LICENSE.  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT
// HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED
// WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
// BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
// WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
// OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
// IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

#include <gtest/gtest.h>
#include "../cola/binary/packets.h"

using namespace snark::sick::cola::binary;

void display_packet_info(const scan_packet & p) {
    std::cerr << "valid     : " << std::boolalpha << p.valid() << std::endl;
    std::cerr << "type      : " << p.body_header().command_type() << " " << p.body_header().type() << std::endl;
    // std::cerr << "length    : " << p.header().length() << " B" << std::endl;
    std::cerr << "serial no : " << "0x" << std::hex << p.device().serial_number() << std::dec << " / " << p.device().serial_number() << std::endl;
    // std::cerr << "uptime    : " << p.status().time_since_boot() << " us" << std::endl;
    // std::cerr << "digitalout: " << "0x" << std::hex << p.status().digital_output_state() << std::dec << std::endl;
    std::cerr << "scan freq : " << p.frequency().scan_frequency() / 100.0 << " Hz" << std::endl;
    // std::cerr << "shot freq : " << p.frequency().measurement_frequency() / 100.0 << " Hz" << std::endl; // todo: not sure if scaling is really 100 Hz
    // std::cerr << "encoders  : " << p.encoders().encoders_size() << std::endl;
    std::cerr << "chans 16b : " << p.channels16().channels_size() << std::endl;
    const scan_packet::channel16_t* c16 = NULL;
    for ( unsigned int ch16id = 0; ch16id < p.channels16().channels_size(); ++ch16id )
    {
        c16 = p.channels16().channels_next(c16);
        std::cerr << "chan16[" << ch16id << "] : " << c16->channel_content()
                  << ", x" << c16->scale_factor()
                  << ", +" << c16->scale_offset()
                  << ", start_angle=" << c16->start_angle() / 10000.0 << " deg"
                  << ", steps=" << c16->steps() / 10000.0 << " deg"
                  << ", length=" << c16->data_size() << std::endl;
    }
    std::cerr << "chans 8b  : " << p.channels8().channels_size() << std::endl;
    const scan_packet::channel8_t* c8 = NULL;
    for ( unsigned int ch8id = 0; ch8id < p.channels8().channels_size(); ++ch8id )
    {
        c8 = p.channels8().channels_next(c8);
        std::cerr << "chan8[" << ch8id << "]  : " << c8->channel_content()
                  << ", x" << c8->scale_factor()
                  << ", +" << c8->scale_offset()
                  << ", start_angle=" << c8->start_angle() / 10000.0 << " deg"
                  << ", steps=" << c8->steps() / 10000.0 << " deg"
                  << ", length=" << c8->data_size() << std::endl;
    }
    // std::cerr << "position  : " << p.position().data_present() << std::endl;
    std::string name = "<not present>";
    if ( p.name().data_present() == 1 ) { name = std::string(p.name().name()->name_begin()->data(), p.name().name()->name_end()->data()); }
    std::cerr << "name      : " << name << std::endl;
    // std::cerr << "comment   : " << p.comment().data_present() << std::endl;
    std::ostringstream timess;
    if ( p.time().data_present() == 1 ) { timess << (int)p.time().timestamp()->year() << (int)p.time().timestamp()->month() << (int)p.time().timestamp()->day()
                                                 << "T" << (int)p.time().timestamp()->hour() << (int)p.time().timestamp()->minute() << (int)p.time().timestamp()->second()
                                                 << "." << p.time().timestamp()->microseconds(); }
    else { timess << "<not present>"; }
    std::cerr << "timestamp : " << timess.str() << std::endl;
    // std::cerr << "event     : " << p.event().data_present() << std::endl;
    std::cerr << "crc       : " << "0x" << std::hex << (unsigned int)p.crc() << std::dec << std::endl << std::endl;
}


TEST( cola, binary_packet_basics )
{
    packet< payloads::set_access_mode::request > request;
    // todo: test something...
}


TEST( cola, scan_packet_from_documentation )
{
    // example packet from Section 6.4.1 p40 of Sick LMS151 telegram documentation v1.0 (04.07.14 - 8016687/0000/2014-07-04)
    // Note this doesn't exercise much of the packet at all (most optional components are not present, only 1x 16-bit channel)
    const unsigned char buf[] = { 0x02,0x02,0x02,0x02,0x00,0x00,0x00,0x83,0x73,0x52,0x41,0x20,0x4C,0x4D,0x44,0x73,0x63,0x61,0x6E,0x64,0x61,0x74,0x61,0x20,0x00,0x01,0x00,0x01,
                         0x00,0x89,0xA2,0x7F,0x00,0x00,0xC8,0xC8,0xC8,0xCC,0x15,0x58,0x86,0xD8,0x15,0x58,0x8C,0x5A,0x00,0x00,0x07,0x00,0x00,0x00,0x00,0x00,0x13,0x88,
                         0x00,0x00,0x01,0x68,0x00,0x00,0x00,0x01,0x44,0x49,0x53,0x54,0x31,0x3F,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x86,0xA0,0x13,0x88,0x00,
                         0x15,0x08,0x93,0x08,0x95,0x08,0xAF,0x08,0xB3,0x08,0xB0,0x08,0xA4,0x08,0xB0,0x08,0xBF,0x08,0xB9,0x08,0xBA,0x08,0xD0,0x08,0xD3,0x08,0xCF,0x08,
                         0xDE,0x08,0xEB,0x08,0xE3,0x08,0xFE,0x08,0xEC,0x09,0x03,0x08,0xFD,0x08,0xFD,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x2B };
    scan_packet p = scan_packet(reinterpret_cast<const char*>( buf ));
    display_packet_info( p );

    EXPECT_TRUE( p.valid() );
    EXPECT_EQ( 1, p.channels16().channels_size() ) << "should be 1: single return";
    EXPECT_EQ( 0, p.channels8().channels_size() ) << "no rssi";
    EXPECT_EQ( 0, p.encoders().encoders_size() );
    EXPECT_EQ( 0, p.time().data_present() );
    EXPECT_EQ( 0, p.name().data_present() );
    EXPECT_EQ( 0, p.comment().data_present() );
    EXPECT_EQ( 0, p.position().data_present() );
    EXPECT_EQ( 0, p.event().data_present() );
}

TEST( cola, DISABLED_scan_packet_with_remission8b_and_timestamp )
{
    // example from lidar
    // % sick-lms151-stream -v --skip=25 --hex --no_stop --start_angle=0 --stop_angle=0.25 --frequency=25 --resolution=0.25 --remission --remission_resolution=8 192.168.1.12
    const unsigned char buf[] = { 0x02,0x02,0x02,0x02,0x00,0x00,0x00,0x7f,0x73,0x53,0x4e,0x20,0x4c,0x4d,0x44,0x73,0x63,0x61,0x6e,0x64,0x61,0x74,0x61,0x20,0x00,0x01,0x00,0x01,0x00,0xc8,0xa7,0x38,0x00,0x00,0x00,0x80,0x04,0x26,0x09,0xc3,0x83,0x02,0x09,0xc4,0x34,0x7a,0x00,0x00,0x07,0x00,0x00,0x00,0x00,0x00,0x09,0xc4,0x00,0x00,0x01,0x68,0x00,0x00,0x00,0x01,0x44,0x49,0x53,0x54,0x31,0x3f,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x09,0xc4,0x00,0x02,0x00,0x22,0x00,0x2f,0x00,0x01,0x52,0x53,0x53,0x49,0x31,0x3f,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x09,0xc4,0x00,0x02,0x1f,0x1f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x07,0xde,0x08,0x1d,0x0c,0x08,0x1e,0x00,0x05,0x3b,0xd8,0x00,0x00,0x97 };
    scan_packet p = scan_packet(reinterpret_cast<const char*>( buf ));
    display_packet_info( p );

    EXPECT_TRUE( p.valid() );
    EXPECT_EQ( 1, p.channels16().channels_size() ) << "single range return channel";
    EXPECT_EQ( 1, p.channels8().channels_size() ) << "rssi of single range return";
    EXPECT_EQ( 0, p.encoders().encoders_size() );
    EXPECT_EQ( 1, p.time().data_present() ) << "timestamps requested";
    EXPECT_EQ( 0, p.name().data_present() );
    EXPECT_EQ( 0, p.comment().data_present() );
    EXPECT_EQ( 0, p.position().data_present() );
    EXPECT_EQ( 0, p.event().data_present() );
}

TEST( cola, DISABLED_scan_packet_with_remission8b_encoder_and_timestamp )
{
    // example from lidar
    // % sick-lms151-stream -v --skip=25 --hex --no_stop --start_angle=0 --stop_angle=0.25 --frequency=25 --resolution=0.25 --remission --remission_resolution=8 --encoder 192.168.1.12
    const unsigned char buf[] = { 0x02,0x02,0x02,0x02,0x00,0x00,0x00,0x85,0x73,0x53,0x4e,0x20,0x4c,0x4d,0x44,0x73,0x63,0x61,0x6e,0x64,0x61,0x74,0x61,0x20,0x00,0x01,0x00,0x01,0x00,0xc8,0xa7,0x38,0x00,0x00,0x00,0xbc,0x00,0x35,0x0f,0xd8,0x2f,0xed,0x0f,0xd8,0xe2,0x7e,0x00,0x00,0x07,0x00,0x00,0x00,0x00,0x00,0x09,0xc4,0x00,0x00,0x01,0x68,0x00,0x01,0x00,0x00,0x00,0x00,0x03,0xe8,0x00,0x01,0x44,0x49,0x53,0x54,0x31,0x3f,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x09,0xc4,0x00,0x02,0x00,0x2f,0x00,0x33,0x00,0x01,0x52,0x53,0x53,0x49,0x31,0x3f,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x09,0xc4,0x00,0x02,0x1f,0x1f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x07,0xde,0x08,0x1d,0x0c,0x0a,0x0c,0x00,0x05,0x2c,0x38,0x00,0x00,0x36 };
    scan_packet p = scan_packet(reinterpret_cast<const char*>( buf ));
    display_packet_info( p );

    EXPECT_TRUE( p.valid() );
    EXPECT_EQ( 1, p.channels16().channels_size() ) << "single range return channel";
    EXPECT_EQ( 1, p.channels8().channels_size() ) << "rssi of single range return";
    EXPECT_EQ( 1, p.encoders().encoders_size() );
    EXPECT_EQ( 1, p.time().data_present() ) << "timestamps requested";
    EXPECT_EQ( 0, p.name().data_present() );
    EXPECT_EQ( 0, p.comment().data_present() );
    EXPECT_EQ( 0, p.position().data_present() );
    EXPECT_EQ( 0, p.event().data_present() );
}

TEST( cola, scan_packet_with_remission16b_name_and_timestamp )
{
    // example from lidar
    // % sick-lms151-stream -v --skip=25 --hex --no_stop --start_angle=-1 --stop_angle=1 --frequency=25 --resolution=0.25 --name --remission --remission_resolution=16 192.168.1.12
    const unsigned char buf[] = { 0x02,0x02,0x02,0x02,0x00,0x00,0x00,0xaa,0x73,0x53,0x4e,0x20,0x4c,0x4d,0x44,0x73,0x63,0x61,0x6e,0x64,0x61,0x74,0x61,0x20,0x00,0x01,0x00,0x01,0x00,0xc8,0xa7,0x38,0x00,0x00,0x00,0xde,0x03,0x27,0x14,0x56,0x0c,0xd9,0x14,0x56,0xbe,0x28,0x00,0x00,0x07,0x00,0x00,0x00,0x00,0x00,0x09,0xc4,0x00,0x00,0x01,0x68,0x00,0x00,0x00,0x02,0x44,0x49,0x53,0x54,0x31,0x3f,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0xd8,0xf0,0x09,0xc4,0x00,0x09,0x00,0x3c,0x00,0x31,0x00,0x3c,0x00,0x31,0x00,0x34,0x00,0x46,0x00,0x41,0x00,0x46,0x00,0x2e,0x52,0x53,0x53,0x49,0x31,0x3f,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0xd8,0xf0,0x09,0xc4,0x00,0x09,0x01,0xf9,0x01,0xfa,0x01,0xfc,0x01,0xfb,0x01,0xfa,0x01,0xfb,0x01,0xfb,0x01,0xfb,0x01,0xfa,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x0b,0x6e,0x6f,0x74,0x20,0x64,0x65,0x66,0x69,0x6e,0x65,0x64,0x00,0x00,0x00,0x01,0x07,0xde,0x08,0x1d,0x0c,0x0b,0x1b,0x00,0x0a,0x8f,0x20,0x00,0x00,0x95 };
    scan_packet p = scan_packet(reinterpret_cast<const char*>( buf ));
    display_packet_info( p );

    EXPECT_TRUE( p.valid() );
    EXPECT_EQ( 2, p.channels16().channels_size() ) << "single range with RSSI in 16-bit";
    EXPECT_EQ( 0, p.channels8().channels_size() ) << "rssi in 16-bit channel";
    EXPECT_EQ( 0, p.encoders().encoders_size() );
    EXPECT_EQ( 1, p.time().data_present() ) << "timestamps requested";
    EXPECT_EQ( 1, p.name().data_present() );
    EXPECT_EQ( 0, p.comment().data_present() );
    EXPECT_EQ( 0, p.position().data_present() );
    EXPECT_EQ( 0, p.event().data_present() );
}

TEST( cola, scan_packet_with_the_lot )
{
    // example packet from actual lidar
    // % sick-lms151-stream -v --skip=25 --hex --no_stop --start_angle=-5 --stop_angle=5 --frequency=25 --resolution=0.25 --second_return --name --encoder --position --comment --remission --remission_resolution=16 192.168.1.12
    const unsigned char buf[] = { 0x02,0x02,0x02,0x02,0x00,0x00,0x01,0xfe,0x73,0x53,0x4e,0x20,0x4c,0x4d,0x44,0x73,0x63,0x61,0x6e,0x64,0x61,0x74,0x61,0x20,0x00,0x01,0x00,0x01,0x00,0xc8,0xa7,0x38,0x00,0x00,0x09,0x93,0x01,0x7d,0xc6,0x70,0xfe,0x4c,0xc6,0x71,0xaf,0xf3,0x00,0x00,0x07,0x00,0x00,0x00,0x00,0x00,0x09,0xc4,0x00,0x00,0x01,0x68,0x00,0x01,0x00,0x00,0x00,0x00,0x03,0xe8,0x00,0x04,0x44,0x49,0x53,0x54,0x31,0x3f,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0x3c,0xb0,0x09,0xc4,0x00,0x29,0x00,0x3a,0x00,0x35,0x00,0x33,0x00,0x3e,0x00,0x3e,0x00,0x3d,0x00,0x29,0x00,0x3d,0x00,0x3d,0x00,0x45,0x00,0x44,0x00,0x42,0x00,0x37,0x00,0x41,0x00,0x34,0x00,0x3f,0x00,0x33,0x00,0x36,0x00,0x3c,0x00,0x28,0x00,0x2d,0x00,0x34,0x00,0x40,0x00,0x3c,0x00,0x3e,0x00,0x40,0x00,0x40,0x00,0x46,0x00,0x2d,0x00,0x2b,0x00,0x3a,0x00,0x33,0x00,0x37,0x00,0x32,0x00,0x3c,0x00,0x38,0x00,0x2e,0x00,0x30,0x00,0x34,0x00,0x39,0x00,0x40,0x44,0x49,0x53,0x54,0x32,0x3f,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0x3c,0xb0,0x09,0xc4,0x00,0x29,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x52,0x53,0x53,0x49,0x31,0x3f,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0x3c,0xb0,0x09,0xc4,0x00,0x29,0x01,0xe9,0x01,0xeb,0x01,0xeb,0x01,0xed,0x01,0xee,0x01,0xee,0x01,0xf1,0x01,0xf4,0x01,0xf2,0x01,0xf4,0x01,0xf5,0x01,0xf4,0x01,0xf8,0x01,0xf9,0x01,0xf9,0x01,0xf9,0x01,0xfc,0x01,0xfb,0x01,0xfb,0x01,0xfd,0x01,0xfe,0x01,0xfe,0x01,0xfc,0x01,0xfc,0x01,0xfd,0x01,0xfb,0x01,0xfb,0x01,0xfb,0x01,0xfa,0x01,0xfb,0x01,0xf9,0x01,0xf9,0x01,0xf8,0x01,0xf7,0x01,0xf3,0x01,0xf4,0x01,0xf3,0x01,0xf2,0x01,0xf0,0x01,0xf0,0x01,0xed,0x52,0x53,0x53,0x49,0x32,0x3f,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0x3c,0xb0,0x09,0xc4,0x00,0x29,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x0b,0x4c,0x4d,0x53,0x31,0x35,0x31,0x20,0x54,0x65,0x73,0x74,0x00,0x00,0x00,0x01,0x07,0xde,0x08,0x1d,0x0b,0x2c,0x15,0x00,0x0c,0x0a,0x08,0x00,0x00,0x1e };
    scan_packet p = scan_packet(reinterpret_cast<const char*>( buf ));
    display_packet_info( p );

    EXPECT_TRUE( p.valid() );
    EXPECT_EQ( 4, p.channels16().channels_size() ) << "two return channels + rssi as 16-bit for each";
    EXPECT_EQ( 0, p.channels8().channels_size() ) << "rssi in 16-bit channels";
    EXPECT_EQ( 1, p.encoders().encoders_size() );
    EXPECT_EQ( 1, p.time().data_present() ) << "timestamps requested";
    EXPECT_EQ( 1, p.name().data_present() );
    EXPECT_EQ( 0, p.comment().data_present() ) << "requested but not supported";
    EXPECT_EQ( 0, p.position().data_present() ) << "requested but not supported";
    EXPECT_EQ( 0, p.event().data_present() ) << "requested but not supported";
}
